###
Writing programs that work when everything goes as expected is a good
start.  Making your programs behave properly when encountering unexpected
conditions  is where it really gets challenging.

The problematic situations a program may encounter fall into two categories:
programmer mistakes and genuine problems. To counter some of the negative
effects associated with malfunctioning software (so called 'buggy' behaviour),
we can employ a strategy based on the elegant handling of errors generated by
program exceptions/events.

The theory behind exception handling goes like this: It is possible for code
to raise (or throw) an exception, which is a value. Raising an exception
somewhat resembles a super-charged return from a function — it does not just
jump out of the current function, but also out of its callers, all the way up
to the top-level call that started the current execution. This is called
unwinding the stack↓. You may remember the stack↓ of function calls that was
mentioned in Functions↑. An exception zooms down this stack, throwing away all
the call contexts it encounters.

If they always zoomed right down to the base of the stack, exceptions would
not be of much use, they would just provide a novel way to blow up your
program. Fortunately, it is possible to set obstacles for exceptions along the
stack. These ‘catch’↓ the exception as it is zooming down, and can do
something with it, after which the program continues running at the point
where the exception was caught. An example in short-hand pseudo-code:

someMethod: (array) ->
  if conditionIsAccepted(arg)
    doSomething()
  else
    throw 'this error message' +
          'string of text chars'

otherMethod = (array) ->
  # calls the previous method
  someMethod(array)

try
  # to execute the second method
  show otherMethod []
  # which relays it back to the first
  # and now
catch error
  show 'Something bad has happend' + error

  ###





